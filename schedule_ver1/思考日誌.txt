2023_09_23:
今天親戚上來北部，有相約吃個飯，進度比較不多。
今天在思考將TIME_TABLE分出來，來讓整個schedule程式碼不要長太胖。
2023_09_24:
在排flow的時候發現先把TIME_TABLE弄出來也沒辦法做到好，有考慮把TIME_TABLE放到最後再拿出來使用(demo階段)
目前還是利用path_dic來整理flow為主，但目前還卡在排每個flow_中間path2的時間，這個動作要怎麼寫比較好，(想不出來要怎麼寫(schedule_middle的部分))
之前有寫過但是那個是硬排的(依照flow的規格直接排)，沒有先與其他flow比較相同path上的衝突問題，並利用篇一時間來達成排成問題，而是先硬排然後在比較衝突，但這樣的話就缺少彈性排程這個效果了。
先跟老師說抱歉我真的想很久，刪了又刪，改了又刪。有可能是我真的把問題想得太複雜，讓整個結構的設計很不好(其實看上去是看得動的，但是可能這樣的設計方式對後續排程操作是非常困難的)
18:53先發佈一次，等等00:00我在想一下寫法重新發佈一次....

2023_09_25:
現在目前卡在schedule_middle這段程式瑪上面，用了四個for的巢狀迴圈為了就是讓有共同link的flow整理出來，並利用time_occupy_list來查看這link上有那些時間點已經被佔據的，但這個方法有個缺失的地方，
就是他可以挑選出共同Link，但沒辦法記著前後link的關聯性.......。還在想有甚麼方法可以同時做到這幾件事情.....。
※之前是先在同個flow上面依據第一格link的時間，依照flow的size、priod自動向後推算後走過隨後link的占用時間點，但這樣的話就沒有彈性排程的效果(彈性排程效果就是，在排成的時候如果遇到相同link上同時間點上，同時有兩格flow占用，則可以依據其他條件前後推移時間點，讓以讓這兩個flow都有機會成功傳輸)，只能硬生生地把相同占用的flow選擇性地放棄排程。
